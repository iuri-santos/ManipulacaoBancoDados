---
title: "Desafio - 10"
author: "Iuri Santos Oliveira"
format: html
editor: visual
---

```{r}
data_hora_geracao <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
cat("Relatório gerado em:", data_hora_geracao, "\n\n")
```

## Introdução ao Polars

```{python}
# Instalação das bibliotecas necessárias (descomentar se necessário)
# polars: biblioteca principal para manipulação de dados
# fastexcel: para leitura rápida de arquivos Excel
# pyarrow: backend para operações otimizadas
#!pip install polars
#!pip install fastexcel
#!pip install pyarrow
```

```{python}
# Importa a biblioteca Polars com alias 'pl'
import polars as pl
```

```{python}
# Lê arquivo CSV de aeroportos selecionando apenas 3 colunas específicas
aeroportos = pl.read_csv("../dados/airports.csv", columns = ["IATA_CODE", "CITY", "STATE"])

# Exibe as 2 primeiras linhas do DataFrame
aeroportos.head(2)
```

```{python}
# Lê planilha Excel do World Development Indicators
# sheet_name: especifica a aba "Country" do arquivo
# columns: seleciona apenas as colunas "Short Name" (nome do país) e "Region" (região)

wdi = pl.read_excel("../dados/WDIEXCEL.xlsx", sheet_name = "Country", columns = ["Short Name", "Region"])
wdi.head(2)
```

```{python}
# Cria um DataFrame exemplo com 3 colunas
df = pl.DataFrame({
  "grupo": ["A", "A", "B", "B", "C"],
  "valor1": [10, 15, 10, None, 25],
  "valor2":  [5, None, 20, 30, None]
})

# Exibe o DataFrame completo
df

# Seleciona apenas a coluna "valor1"
df["valor1"]

# Remove valores nulos da coluna "valor1"
df["valor1"].drop_nulls()

# Calcula a média dos valores não-nulos de "valor1"
df["valor1"].drop_nulls().mean()

# Usa select para calcular estatísticas de múltiplas colunas
# alias: renomeia a coluna resultante
df.select([
  pl.col("valor1").mean().alias("media_v1"),  # Média de valor1
  pl.col("valor2").mean()                      # Média de valor2
  ])
```

```{python}
# Agrupa dados por "grupo" e calcula estatísticas
df.group_by("grupo").agg([
  pl.col("valor1").mean().alias("media_valor1"),  # Média de valor1 por grupo
  pl.col("valor2").min().alias("min_valor2")      # Valor mínimo de valor2 por grupo
]).sort("grupo")  # Ordena resultado alfabeticamente por grupo
```

```{python}
voos = pl.read_csv("../dados/flights.csv",
                   # Seleciona apenas 3 colunas relevantes
                   columns = ["AIRLINE", "ARRIVAL_DELAY", "DESTINATION_AIRPORT"],
                   # Define tipos de dados para cada coluna
                   dtypes = {"AIRLINE": pl.Utf8,              # String
                             "ARRIVAL_DELAY": pl.Int32,        # Inteiro 32 bits
                             "DESTINATION_AIRPORT": pl.Utf8})  # String

# Exibe dimensões do DataFrame (linhas, colunas)
voos.shape

# Mostra as 3 primeiras linhas
voos.head(3)
```

```{python}
# Pipeline de processamento de dados de voos
resultado = (
  # Remove linhas com valores nulos nas colunas especificadas
  voos.drop_nulls(["AIRLINE", "DESTINATION_AIRPORT", "ARRIVAL_DELAY"])
  # Filtra apenas companhias aéreas AA e DL
  # E aeroportos SEA (Seattle), MIA (Miami) e BWI (Baltimore)
  .filter(
    pl.col("AIRLINE").is_in(["AA", "DL"]) &
    pl.col("DESTINATION_AIRPORT").is_in(["SEA", "MIA", "BWI"])
    )
    # Agrupa por companhia aérea e aeroporto de destino
    .group_by(["AIRLINE", "DESTINATION_AIRPORT"])
    # Calcula a proporção de voos com atraso > 30 minutos
    .agg([
      (pl.col("ARRIVAL_DELAY") > 30).mean().alias("atraso_medio")
      ])
)

# Ordena resultado por proporção de atraso (do menor para o maior)
resultado.sort("atraso_medio")
```

## Dados Relacionais com Polars

```{python}
import polars as pl

# Cria DataFrame de clientes com ID e nome
clientes = pl.DataFrame({
    "cliente_id": [1, 2, 3, 4],
    "nome": ["Ana", "Bruno", "Clara", "Daniel"]
})

print(clientes)
```

```{python}
# Cria DataFrame de pedidos com ID do pedido, ID do cliente e valor
# Nota: cliente_id 5 não existe na tabela de clientes
pedidos = pl.DataFrame({
    "pedido_id": [101, 102, 103, 104, 105],
    "cliente_id": [1, 2, 3, 1, 5],
    "valor": [100.50, 250.75, 75.00, 130.00, 79.00]
})

print(pedidos)
```

```{python}
# INNER JOIN - Retorna apenas as linhas que têm correspondências nas duas tabelas
# Mantém apenas clientes que fizeram pedidos
res_ij = clientes.join(pedidos, on="cliente_id", how="inner")
print(res_ij)
```

```{python}
# LEFT JOIN - Retorna todas as linhas da tabela à esquerda (clientes)
# Clientes sem pedidos terão valores nulos nas colunas de pedidos
res_lj = clientes.join(pedidos, on="cliente_id", how="left")
print(res_lj)
```

```{python}
# RIGHT JOIN - Retorna todas as linhas da tabela à direita (pedidos)
# Pedidos de clientes inexistentes terão valores nulos nas colunas de clientes
res_rj = clientes.join(pedidos, on="cliente_id", how="right")
print(res_rj)
```

```{python}
# OUTER JOIN - Retorna todas as linhas de ambas as tabelas
# Combina LEFT e RIGHT JOIN, mantendo todas as linhas
res_oj = clientes.join(pedidos, on="cliente_id", how="outer")
print(res_oj)
```

```{python}
# CROSS JOIN - Retorna o produto cartesiano de ambas as tabelas
# Cada cliente é combinado com cada pedido (4 clientes × 5 pedidos = 20 linhas)
res_cj = clientes.join(pedidos, how="cross")
print(res_cj)
```

1.  Qual é o valor médio das compras realizadas para cada cliente identificado?

```{python}
# Exibe tabelas originais para referência
print(clientes)
print(pedidos)

# Usa INNER JOIN para combinar clientes com seus pedidos
# Agrupa por nome e ID do cliente
# Calcula a média dos valores de compra para cada cliente
res = res_ij.group_by(["nome", "cliente_id"]).agg(pl.col("valor").mean())
print(res)
```

2.  Informe os nomes e a quantidade de compras com valor mínimo de \$100.00 realizadas por cada cliente.

```{python}
# Exibe tabelas originais
print(clientes)
print(pedidos)

# Usa OUTER JOIN para incluir todos os clientes
# Cria coluna booleana: valor > 100 (True/False)
# Agrupa por nome e soma valores True (conta compras > $100)
res = (res_oj.with_columns(pl.col("valor") > 100)
       .group_by("nome")
       .agg(pl.col("valor").sum()))
print(res)
```

```{python}
# JOIN com Múltiplas Colunas como Chave
# Útil quando a combinação de várias colunas identifica unicamente uma linha

# DataFrame de vendas: ID da venda, cliente, produto e quantidade
vendas = pl.DataFrame({
    "id_venda": [1, 2, 3],
    "id_cl": [1, 2, 1],
    "id_prod": [101, 102, 103],
    "qtde": [2, 1, 1]
})

# DataFrame de detalhes: ID do pedido, cliente, produto e valor
detalhes_pedidos = pl.DataFrame({
    "id_ped": [201, 202, 203],
    "cl_id": [1, 2, 1],
    "id_prod": [101, 102, 104],
    "valor": [50.00, 75.00, 100.00]
})

print(vendas)
print(detalhes_pedidos)

# Realiza JOIN usando duas colunas como chave
# left_on: colunas da tabela da esquerda [cliente, produto]
# right_on: colunas correspondentes da tabela da direita
# Combina apenas quando AMBAS as colunas coincidem
final = vendas.join(detalhes_pedidos,
                    left_on = ["id_cl", "id_prod"],
                    right_on = ["cl_id", "id_prod"],
                    how = "inner")
print(final)
```
