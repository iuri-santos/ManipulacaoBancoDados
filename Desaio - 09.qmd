---
title: "Desafio - 09"
author: "Iuri Santos Oliveira"
format: html
editor: visual
---

## Atividade
```{r}
data_hora_geracao <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
cat("Relatório gerado em:", data_hora_geracao, "\n\n")
```

1. Crie um arquivo de banco de dados em SQLite chamado `voos.sqlite3`. (Dica: o comando `dbConnect()` se conecta num banco de dados se o arquivo apontado existir ou cria um novo, caso o arquivo não exista.)
```{r}
# Bibliotecas necessárias
library(RSQLite)

# Conecta (cria o arquivo se não existir)
conn <- dbConnect(RSQLite::SQLite(), dbname = "voos.sqlite3")

```

2. Leia os arquivos `airlines.csv` e `airports.csv`. Deposite o conteúdo de cada um destes arquivos nas tabelas, respectivamente, `airlines` e `airports`. Utilize o comando `dbWriteTable()` para isso.
```{r}
# Bibliotecas necessárias
library(readr)

# Lê os CSVs
airlines_df <- read_csv(unz("flights.csv.zip", "airlines.csv"))
airports_df <- read_csv(unz("flights.csv.zip", "airports.csv"))

# grava as tabelas no banco (sobrescreve se já existirem)
dbWriteTable(conn, "airlines", airlines_df, overwrite = TRUE)
dbWriteTable(conn, "airports", airports_df, overwrite = TRUE)
```

3. Crie uma função chamada `lerDados` contendo 2 argumentos, `input` e `pos`. A função deve apresentar ao usuário uma mensagem de progresso da leitura do arquivo `flights.csv` (utilize o comando `message()`), aos moldes do apresentado abaixo. A função deve salvar apenas os vôos que partiram ou chegaram aos seguintes aeroportos `BWI`, `MIA`, `SEA`, `SFO` e `JFK`, numa tabela chamada `flights`. Observe que a função não deve retornar nada para o usuário, deve apenas gravar a tabela obtida do chunk no banco de dados. (Dica: utilize o comando `dbWriteTable()` e estude como o argumento append deve ser utilizado para permitir que os `chunks` intermediários sejam adicionados ao fim da tabela.)


```{r}
# Aeroportos de interesse
aeroportos_interesse <- c("BWI", "MIA", "SEA", "SFO", "JFK")

# Função que será chamada para cada chunk
lerDados <- function(input, pos) {
  # Mensagem de progresso (conforme enunciado)
  message("Leitura atingiu a linha ", pos)
  
  # Filtra apenas os voos cuja origem OU destino está entre os aeroportos de interesse
  chunk_filtrado <- input[
    (input$ORIGIN_AIRPORT %in% aeroportos_interesse) |
    (input$DESTINATION_AIRPORT %in% aeroportos_interesse),
    , drop = FALSE
  ]
  
  # Gravar no banco
  dbWriteTable(conn, "flights", chunk_filtrado, append = TRUE)
}

```

4. Leia o arquivo `flights.csv`, restringindo-se às colunas `YEAR`, `MONTH`, `DAY`, `AIRLINE`, `FLIGHT_NUMBER`, `ORIGIN_AIRPORT`, `DESTINATION_AIRPORT` e `ARRIVAL_DELAY`, e aplique a função `lerDados()` criada acima. Observe, novamente, que a função `lerDados()` não retorna nada para o usuário. Por isso, a função de callback a ser utilizada é `SideEffectChunkCallback$new()`. Leia 100 mil registros por vez.
```{r}
# Colunas que queremos ler 
colunas_selecionadas <- c("YEAR","MONTH","DAY","AIRLINE","FLIGHT_NUMBER",
                          "ORIGIN_AIRPORT","DESTINATION_AIRPORT","ARRIVAL_DELAY")

# Cria o callback do readr que chama a função lerDados a cada chunk
callback <- SideEffectChunkCallback$new(lerDados)

# Executa a leitura em chunks de 100000 linhas diretamente do arquivo dentro do zip
read_csv_chunked(
  file = unz("flights.csv.zip", "flights.csv"), 
  callback = callback,
  chunk_size = 100000,
  col_types = cols(.default = col_guess())
)
```

5. Acesse o banco de dados e, por meio de uma chamada em SQL, apresente o tempo médio de atraso de chegada por aeroporto de destino, a sigla do aeroporto, o nome completo do aeroporto e o nome completo da companhia aérea. Ordene o resultado (na mesma chamada de SQL) por ordem decrescente deste atraso médio (i.e., o primeiro registro deve ser o aeroporto que tem o maior tempo de atraso na chegada). Atente para o fato de que o mesmo nome de coluna pode acontecer em diferentes tabelas.
```{r}
library(knitr)
library(kableExtra)
# Ajuste os nomes (por exemplo IATA_CODE, FAA_CODE, NAME, AIRLINE_NAME) conforme a sua estrutura.
sql <- "SELECT 
    f.DESTINATION_AIRPORT AS sigla_aeroporto,
    a.AIRPORT AS nome_aeroporto,
    l.AIRLINE AS nome_companhia,
    AVG(f.ARRIVAL_DELAY) AS tempo_medio_atraso
FROM flights f
JOIN airports a 
    ON f.DESTINATION_AIRPORT = a.IATA_CODE
JOIN airlines l 
    ON f.AIRLINE = l.IATA_CODE
GROUP BY f.DESTINATION_AIRPORT, l.AIRLINE
ORDER BY tempo_medio_atraso DESC
"

# Executa a consulta no banco SQLite
resultado <- dbGetQuery(conn, sql)

# Mostra as 20 primeiras linhas em uma tabela formatada
resultado %>%
  head(20) %>%
  kable("html", caption = "Top 20 maiores atrasos médios por aeroporto de destino e companhia") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"))

dbDisconnect(conn)
```

